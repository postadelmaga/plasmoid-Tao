<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystical Tao</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: transparent;
            overflow: hidden;
            /* Aggiunge sfocatura allo sfondo dietro al contenuto HTML */
            backdrop-filter: blur(15px) brightness(0.9);
        }

        canvas {
            filter: contrast(1.1);
        }
    </style>
</head>

<body>
    <canvas id="taoCanvas"></canvas>

    <script>
        const canvas = document.getElementById("taoCanvas");
        const ctx = canvas.getContext("2d", { alpha: true });

        let PARTICLE_COUNT = 100;
        let ROTATION_SPEED = 0.01;
        let ROTATION_DIRECTION = 1;
        let SHOW_CLOCK = false;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
            radius = Math.min(canvas.width, canvas.height) / 4;
        }

        let centerX, centerY, radius;
        resizeCanvas();

        let rotation = 0;
        let time = 0;

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                const angle = Math.random() * Math.PI * 2;
                const distance = radius + Math.random() * 100;
                this.x = centerX + Math.cos(angle) * distance;
                this.y = centerY + Math.sin(angle) * distance;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.life = 1;
                this.decay = 0.002 + Math.random() * 0.003;
                this.size = Math.random() * 2 + 0.5;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;

                if (this.life <= 0) {
                    this.reset();
                }
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life * 0.6;
                ctx.fillStyle = "#ffffff";
                ctx.shadowBlur = 10;
                ctx.shadowColor = "#88ccff";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        let particles = Array.from({ length: PARTICLE_COUNT }, () => new Particle());

        function drawClockHand(angle, length, width, color, glow) {
            ctx.save();
            ctx.rotate(angle - Math.PI / 2);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(length, 0);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = "round";
            if (glow) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
            }
            ctx.stroke();
            ctx.restore();
        }

        function drawTao() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Sfondo circolare
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius + 40, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
            ctx.fill();
            ctx.restore();

            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            ctx.save();
            ctx.translate(centerX, centerY);

            // Simbolo Tao (Rotante)
            ctx.save();
            ctx.rotate(rotation);

            const pulse = Math.sin(time * 0.05) * 0.2 + 0.8;

            // Glow esterno
            ctx.save();
            ctx.globalAlpha = 0.3 * pulse;
            ctx.strokeStyle = "#88ccff";
            ctx.lineWidth = 2;
            ctx.shadowBlur = 20;
            ctx.shadowColor = "#88ccff";
            ctx.beginPath();
            ctx.arc(0, 0, radius + 40, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            // Aura interna
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
            glowGradient.addColorStop(0, "rgba(136, 204, 255, 0.2)");
            glowGradient.addColorStop(1, "transparent");
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius + 20, 0, Math.PI * 2);
            ctx.fill();

            // Parte bianca (Yin/Yang base)
            const whiteGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
            whiteGradient.addColorStop(0, "#ffffff");
            whiteGradient.addColorStop(1, "#e0e0e0");

            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fillStyle = whiteGradient;
            ctx.fill();

            // Parte nera (Yin/Yang base)
            const blackGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
            blackGradient.addColorStop(0, "#1a1a1a");
            blackGradient.addColorStop(1, "#000000");

            ctx.beginPath();
            ctx.arc(0, 0, radius, -Math.PI / 2, Math.PI / 2, false);
            ctx.arc(0, radius / 2, radius / 2, Math.PI / 2, -Math.PI / 2, true);
            ctx.arc(0, -radius / 2, radius / 2, Math.PI / 2, -Math.PI / 2, false);
            ctx.closePath();
            ctx.fillStyle = blackGradient;
            ctx.fill();

            // Occhio bianco in campo nero
            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#ffffff";
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(0, -radius / 2, radius / 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Occhio nero in campo bianco
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = "#000000";
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(0, radius / 2, radius / 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Linea S centrale luminosa
            ctx.save();
            ctx.globalAlpha = 0.3 * pulse;
            ctx.strokeStyle = "#88ccff";
            ctx.lineWidth = 1;
            ctx.shadowBlur = 10;
            ctx.shadowColor = "#88ccff";
            ctx.beginPath();
            ctx.arc(0, 0, radius, -Math.PI / 2, Math.PI / 2, false);
            ctx.arc(0, radius / 2, radius / 2, Math.PI / 2, -Math.PI / 2, true);
            ctx.arc(0, -radius / 2, radius / 2, Math.PI / 2, -Math.PI / 2, false);
            ctx.stroke();
            ctx.restore();

            // Bordo esterno
            ctx.save();
            ctx.strokeStyle = "#444";
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#88ccff";
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            ctx.restore(); // Fine rotazione Tao

            // Disegna orologio sopra il Tao se attivo
            if (SHOW_CLOCK) {
                const now = new Date();
                const sec = now.getSeconds() + now.getMilliseconds() / 1000;
                const min = now.getMinutes() + sec / 60;
                const hour = (now.getHours() % 12) + min / 60;

                // Lancette
                drawClockHand((hour / 12) * Math.PI * 2, radius * 0.5, 6, "rgba(255, 255, 255, 0.8)", true);
                drawClockHand((min / 60) * Math.PI * 2, radius * 0.8, 4, "rgba(136, 204, 255, 0.8)", true);
                drawClockHand((sec / 60) * Math.PI * 2, radius * 0.9, 1.5, "rgba(255, 170, 136, 0.8)", false);

                // Pivot centrale
                ctx.fillStyle = "#ffffff";
                ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI * 2); ctx.fill();
            }

            // Satelliti orbitanti
            ctx.save();
            ctx.globalAlpha = 0.4;
            for (let i = 0; i < 4; i++) {
                const angle = (time * 0.02) + (i * Math.PI / 2);
                const x = Math.cos(angle) * (radius + 25);
                const y = Math.sin(angle) * (radius + 25);

                ctx.fillStyle = i % 2 === 0 ? "#88ccff" : "#ffaa88";
                ctx.shadowBlur = 20;
                ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            ctx.restore(); // Fine translate(centerX, centerY)
        }

        function animate() {
            rotation += ROTATION_SPEED * ROTATION_DIRECTION;
            time++;
            drawTao();
            requestAnimationFrame(animate);
        }

        window.addEventListener("resize", () => {
            resizeCanvas();
            particles.forEach(p => p.reset());
        });

        // Funzione per aggiornare i parametri dal QML
        window.updateSettings = function (count, speed, direction, showClock) {
            if (PARTICLE_COUNT !== count) {
                PARTICLE_COUNT = count;
                particles = Array.from({ length: PARTICLE_COUNT }, () => new Particle());
            }
            ROTATION_SPEED = speed;
            ROTATION_DIRECTION = direction;
            SHOW_CLOCK = showClock;
        };

        animate();
    </script>
</body>

</html>