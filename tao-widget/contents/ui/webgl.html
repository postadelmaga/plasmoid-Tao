<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: transparent;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #glCanvas {
            z-index: 1;
        }

        #uiCanvas {
            z-index: 2;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <canvas id="glCanvas"></canvas>
    <canvas id="uiCanvas"></canvas>

    <script>
        // --- CONFIGURAZIONE CENTRALE ---
        const Config = {
            particles: 120,
            speed: 0.005,
            direction: 1,
            showClock: false,
            rotation: 0,
            maxParticles: 3000,
            particleColor1: { r: 161, g: 242, b: 252 },
            particleColor2: { r: 255, g: 114, b: 0 },
            glowColor1: 'rgba(100,200,255,0.8)',
            glowSize1: 1.3,
            glowColor2: 'rgba(100,200,255,0)',
            glowSize2: 0.0,
            hourHandColor: 'rgba(255,255,255,1)',
            minuteHandColor: 'rgba(136,204,255,1)',
            secondHandColor: 'rgba(255,170,136,1)',
            particleSize: 4.0,
            particleSizeRandom: 8.0
        };

        const Mouse = { x: -1000, y: -1000, inside: false };

        // --- SHADERS ---
        // OPT 1: il vertex shader ora riceve dati da un singolo buffer interleaved.
        // stride = 7 float = 28 byte per particella: [x, y, r, g, b, a, size]
        const SHADERS = {
            vs: `
                attribute vec2 a_position;
                attribute vec4 a_color;
                attribute float a_size;
                varying vec4 v_color;

                void main() {
                    v_color = a_color;
                    gl_Position = vec4(a_position, 0.0, 1.0);
                    gl_PointSize = a_size;
                }
            `,
            fs: `
                precision mediump float;
                varying vec4 v_color;

                void main() {
                    if (v_color.a < 0.01) discard;

                    vec2 uv = gl_PointCoord - vec2(0.5);
                    float distSq = dot(uv, uv) * 4.0;
                    if (distSq > 1.0) discard;

                    float t = 1.0 - distSq;
                    float core = t * t * t * t * t * t;
                    float intensity = core * 1.5;

                    gl_FragColor = vec4(v_color.rgb * intensity, v_color.a * core);
                }
            `
        };

        // --- HELPERS COLORE ---

        // Converte colori QML/Qt (#AARRGGBB) o CSS (#RRGGBB, #RGB, rgba) in rgba().
        // Bug originale: #RRGGBB passava direttamente senza conversione causando
        // fallback a nero in alcuni contesti del browser.
        function toCssColor(c) {
            if (!c) return 'rgba(128,128,128,1)';
            if (typeof c !== 'string') return 'rgba(128,128,128,1)';
            const s = c.trim();

            // Qt style: #AARRGGBB (9 caratteri)
            if (s.startsWith('#') && s.length === 9) {
                const a = parseInt(s.substr(1, 2), 16) / 255;
                const r = parseInt(s.substr(3, 2), 16);
                const g = parseInt(s.substr(5, 2), 16);
                const b = parseInt(s.substr(7, 2), 16);
                return `rgba(${r},${g},${b},${a.toFixed(4)})`;
            }
            // CSS standard: #RRGGBB (7 caratteri)
            if (s.startsWith('#') && s.length === 7) {
                const r = parseInt(s.substr(1, 2), 16);
                const g = parseInt(s.substr(3, 2), 16);
                const b = parseInt(s.substr(5, 2), 16);
                return `rgba(${r},${g},${b},1)`;
            }
            // CSS short: #RGB (4 caratteri)
            if (s.startsWith('#') && s.length === 4) {
                const r = parseInt(s[1] + s[1], 16);
                const g = parseInt(s[2] + s[2], 16);
                const b = parseInt(s[3] + s[3], 16);
                return `rgba(${r},${g},${b},1)`;
            }
            // Già in formato rgba/rgb
            if (s.startsWith('rgba') || s.startsWith('rgb')) return s;
            // Named colors (white, black…)
            return s;
        }

        // Restituisce lo stesso colore con alpha=0, mantenendo RGB identici.
        // Essenziale per i gradient stop finali: evita l'alone nero che si crea
        // quando si interpola verso rgba(0,0,0,0) invece che verso il colore base
        // trasparente (interpolazione cromatica Canvas2D).
        function toCssColorTransparent(cssColor) {
            if (!cssColor) return 'rgba(0,0,0,0)';
            const m = cssColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (m) return `rgba(${m[1]},${m[2]},${m[3]},0)`;
            return 'rgba(0,0,0,0)';
        }

        // --- CLASSE: OVERLAY 2D (Tao, Glow e Orologio) ---
        class TaoOverlay {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = 0;
                this.height = 0;

                // OPT 3: OffscreenCanvas per il glow — ridisegnato solo quando
                // cambiano colore o dimensione, non ad ogni frame.
                // Il Tao ruota ogni frame, ma il glow è statico: questo elimina
                // la costosa creazione di RadialGradient + fillArc ad ogni frame.
                this.glowCanvas = null;
                this.glowCtx = null;
                this.glowDirty = true;   // forza ridisegno al primo frame
                this._lastGlowColor1 = null;
                this._lastGlowSize1 = null;
                this._lastGlowColor2 = null;
                this._lastGlowSize2 = null;

                // NUOVO: Cache per il Tao (Alta risoluzione)
                this.taoCanvas = document.createElement('canvas');
                this.taoCanvas.width = 1024;
                this.taoCanvas.height = 1024;
                this.taoCtx = this.taoCanvas.getContext('2d');
                this._renderTaoCache(); // Disegna il Tao gigante subito
            }

            resize(w, h) {
                // FIX DPR: canvas fisico = w*dpr × h*dpr pixel, coordinate logiche invariate.
                const dpr = window.devicePixelRatio || 1;
                this.width = w;
                this.height = h;
                this.canvas.width = Math.round(w * dpr);
                this.canvas.height = Math.round(h * dpr);
                this.canvas.style.width = w + 'px';
                this.canvas.style.height = h + 'px';
                // setTransform scala il contesto: ctx.arc(cx,cy,r) funziona in px logici
                this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                // OPT 3: ridimensiona anche il canvas offscreen del glow
                if (typeof OffscreenCanvas !== 'undefined') {
                    this.glowCanvas = new OffscreenCanvas(Math.round(w * dpr), Math.round(h * dpr));
                    this.glowCtx = this.glowCanvas.getContext('2d');
                    this.glowCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
                } else {
                    // Fallback: usa un canvas DOM nascosto per browser senza OffscreenCanvas
                    if (!this.glowCanvas) {
                        this.glowCanvas = document.createElement('canvas');
                        this.glowCtx = this.glowCanvas.getContext('2d');
                    }
                    this.glowCanvas.width = Math.round(w * dpr);
                    this.glowCanvas.height = Math.round(h * dpr);
                    this.glowCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
                }
                this.glowDirty = true; // resize → ridisegna il glow
            }

            // OPT 3: ridisegna il glow sull'offscreen SOLO se qualcosa è cambiato
            _updateGlowCache() {
                const c1 = Config.glowColor1;
                const s1 = Config.glowSize1;
                const c2 = Config.glowColor2;
                const s2 = Config.glowSize2;

                const dirty = this.glowDirty
                    || c1 !== this._lastGlowColor1
                    || s1 !== this._lastGlowSize1
                    || c2 !== this._lastGlowColor2
                    || s2 !== this._lastGlowSize2;

                if (!dirty) return;

                const gc = this.glowCtx;
                const { width, height } = this;
                const r = Math.min(width, height) / 4.5;
                const cx = width / 2;
                const cy = height / 2;

                gc.clearRect(0, 0, width, height);

                const drawGlow = (size, col) => {
                    const radius = r * size;
                    if (!isFinite(radius) || radius <= 0.01) return;
                    const cssCol = toCssColor(col);
                    const grad = gc.createRadialGradient(cx, cy, 0, cx, cy, radius);
                    grad.addColorStop(0, cssCol);
                    // FIX alone nero: fade verso stesso colore con alpha=0, non verso nero
                    grad.addColorStop(0.7, toCssColorTransparent(cssCol).replace(',0)', ',0.3)'));
                    grad.addColorStop(1, toCssColorTransparent(cssCol));
                    gc.fillStyle = grad;
                    gc.beginPath();
                    gc.arc(cx, cy, radius, 0, Math.PI * 2);
                    gc.fill();
                };

                drawGlow(s1, c1);
                drawGlow(s2, c2);

                this._lastGlowColor1 = c1;
                this._lastGlowSize1 = s1;
                this._lastGlowColor2 = c2;
                this._lastGlowSize2 = s2;
                this.glowDirty = false;
            }

            draw() {
                const ctx = this.ctx;
                const { width, height } = this;
                const r = Math.min(width, height) / 4.5;
                const cx = width / 2;
                const cy = height / 2;

                ctx.clearRect(0, 0, width, height);

                // Applica lo smoothing (funziona perfettamente sulle immagini)
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Disegna Glow
                if (this.glowCanvas) {
                    this._updateGlowCache();
                    const dpr = window.devicePixelRatio || 1;
                    ctx.drawImage(this.glowCanvas,
                        0, 0, this.glowCanvas.width, this.glowCanvas.height,
                        0, 0, width, height);
                }

                // Disegna TAO (Usando la cache supersampled)
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(Config.rotation);

                // Disegna l'immagine centrata.
                // Disegniamo da -r a r per centrarla sul punto di rotazione (0,0)
                ctx.drawImage(this.taoCanvas, 0, 0, 1024, 1024, -r, -r, r * 2, r * 2);

                ctx.restore();

                // Disegna Orologio
                if (Config.showClock) {
                    this.drawClock(ctx, cx, cy, r);
                }
            }

            // Genera il Tao a risoluzione fissa 1024x1024
            _renderTaoCache() {
                const ctx = this.taoCtx;
                const size = 1024;
                const r = (size / 2) - 4; // Raggio con un po' di margine per evitare tagli
                const c = size / 2;

                ctx.clearRect(0, 0, size, size);

                // Opzionale: Aggiunge una microscopica sfocatura al bordo per renderlo morbidissimo
                ctx.shadowColor = 'rgba(0,0,0,0.4)';
                ctx.shadowBlur = 4;

                ctx.translate(c, c);

                // 1. BASE NERA
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();

                // Tolgo l'ombra per i dettagli interni per non sporcarli
                ctx.shadowBlur = 0;

                // 2. META' BIANCA
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, 0, r, -Math.PI / 2, Math.PI / 2);
                ctx.fill();

                // 3. MEDIO BIANCO
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(0, r / 2, r / 2, 0, Math.PI * 2); ctx.fill();

                // 4. MEDIO NERO
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(0, -r / 2, r / 2, 0, Math.PI * 2); ctx.fill();

                // 5. PICCOLO NERO
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(0, r / 2, r / 6, 0, Math.PI * 2); ctx.fill();

                // 6. PICCOLO BIANCO
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(0, -r / 2, r / 6, 0, Math.PI * 2); ctx.fill();

                ctx.resetTransform();
            }

            drawClock(ctx, cx, cy, r) {
                const now = new Date();
                const s = now.getSeconds() + now.getMilliseconds() / 1000;
                const m = now.getMinutes() + s / 60;
                const h = (now.getHours() % 12) + m / 60;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.lineCap = 'round';

                const hand = (val, max, len, width, color) => {
                    const angle = (val / max) * Math.PI * 2 - Math.PI / 2;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = width;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
                    ctx.stroke();
                };

                hand(h, 12, r * 0.5, 5, Config.hourHandColor);
                hand(m, 60, r * 0.8, 3, Config.minuteHandColor);
                hand(s, 60, r * 0.9, 1.5, Config.secondHandColor);

                ctx.restore();
            }
        }

        // --- CLASSE: MOTORE PARTICELLE ---
        class ParticleEngine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.gl = this.canvas.getContext('webgl', { alpha: true, antialias: true });

                this.count = Config.maxParticles;
                this.particles = [];
                this.width = 1;
                this.height = 1;

                // OPT 1: buffer interleaved unico invece di 3 buffer separati.
                // Layout per particella: [x, y, r, g, b, a, size] = 7 float = 28 byte
                // Vantaggi: 1 bindBuffer + 1 bufferData invece di 3, migliore cache GPU.
                this.STRIDE = 7;                                    // float per particella
                this.STRIDE_BYTES = this.STRIDE * 4;                      // byte per particella
                this.dataInterleaved = new Float32Array(this.count * this.STRIDE);

                this.initGL();
                this.initParticles();
            }

            initGL() {
                const gl = this.gl;

                const createShader = (type, src) => {
                    const s = gl.createShader(type);
                    gl.shaderSource(s, src);
                    gl.compileShader(s);
                    return s;
                };

                const prog = gl.createProgram();
                gl.attachShader(prog, createShader(gl.VERTEX_SHADER, SHADERS.vs));
                gl.attachShader(prog, createShader(gl.FRAGMENT_SHADER, SHADERS.fs));
                gl.linkProgram(prog);
                gl.useProgram(prog);
                this.program = prog;

                // OPT 1: un solo buffer interleaved
                this.bufInterleaved = gl.createBuffer();

                // OPT 4: cache dei attribute location — getAttribLocation è costoso,
                // chiamarlo una sola volta in init invece che ad ogni frame elimina
                // N query al driver per frame (N = numero di attributi attivi).
                this.loc = {
                    pos: gl.getAttribLocation(prog, 'a_position'),
                    color: gl.getAttribLocation(prog, 'a_color'),
                    size: gl.getAttribLocation(prog, 'a_size'),
                };

                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // additive blending come C++
            }

            resize(w, h) {
                // FIX DPR: canvas WebGL fisicamente più grande su HiDPI.
                // La fisica rimane in pixel logici — solo il viewport cambia.
                const dpr = window.devicePixelRatio || 1;
                const pw = Math.round(w * dpr);
                const ph = Math.round(h * dpr);
                this.canvas.width = pw;
                this.canvas.height = ph;
                this.canvas.style.width = w + 'px';
                this.canvas.style.height = h + 'px';
                this.width = w;
                this.height = h;
                this.gl.viewport(0, 0, pw, ph);
            }

            initParticles() {
                for (let i = 0; i < this.count; i++) {
                    this.particles.push({
                        x: 0, y: 0, vx: 0, vy: 0,
                        life: 0,
                        decay: 0.003 + Math.random() * 0.008,
                        size: Config.particleSize + Math.random() * Config.particleSizeRandom,
                        isFire: (i % 7 === 0)
                    });
                }
            }

            respawn(p, cx, cy, r) {
                p.life = 1.0;
                const angle = Math.random() * Math.PI * 2;
                const dist = r * (0.5 + Math.random() * 2.0);
                p.x = cx + Math.cos(angle) * dist;
                p.y = cy + Math.sin(angle) * dist;
                p.vx = (Math.random() - 0.5) * 0.6;
                p.vy = (Math.random() - 0.5) * 0.6;
                const sdx = p.x - cx;
                const sdy = p.y - cy;
                if (sdx * sdx + sdy * sdy < r * r) p.x += sdx > 0 ? r : -r;
                p.decay = 0.003 + Math.random() * 0.008;
                p.size = Config.particleSize + Math.random() * Config.particleSizeRandom;
            }

            updatePhysics(dt) {
                const df = dt * 60.0;
                const activeCount = Math.min(Config.particles, Config.maxParticles);
                const w = this.width;
                const h = this.height;
                const cx = w * 0.5;
                const cy = h * 0.5;
                const r = Math.min(w, h) / 4.5;
                const rSq = r * r;

                const mx = Mouse.x;
                const my = Mouse.y;
                const isMouseValid = Mouse.inside && mx >= 0 && my >= 0 && mx <= w && my <= h;

                const pc1 = Config.particleColor1;
                const pc2 = Config.particleColor2;

                // OPT 1: pre-calcolo costanti colore fuori dal loop
                const pc1r = pc1.r / 255;
                const pc1g = pc1.g / 255;
                const pc1b = pc1.b / 255;
                const pc2r = pc2.r / 255;
                const pc2b = pc2.b / 255;

                // OPT 1 (friction): già presente, confermato
                const friction = Math.pow(0.98, df);

                const data = this.dataInterleaved;
                const stride = this.STRIDE;

                for (let i = 0; i < activeCount; i++) {
                    const p = this.particles[i];
                    const bi = i * stride; // base index nel buffer interleaved

                    if (p.life > 0.0) {
                        // --- MOUSE ---
                        const dx = mx - p.x;
                        const dy = my - p.y;

                        if (isMouseValid && Math.abs(dx) < 300 && Math.abs(dy) < 300) {
                            const distSq = dx * dx + dy * dy;
                            if (distSq < 90000.0) {
                                const f = 3.5 / (distSq + 100.0);
                                p.vx += dx * f * df;
                                p.vy += dy * f * df;
                            } else {
                                p.vx *= friction;
                                p.vy *= friction;
                            }
                        } else {
                            p.vx *= friction;
                            p.vy *= friction;
                        }

                        // --- MOVIMENTO ---
                        p.x += p.vx * df;
                        p.y += p.vy * df;

                        // --- BOUNDARY ---
                        if (p.x < 0) { p.x = 0; p.vx = Math.abs(p.vx) * 0.4; }
                        else if (p.x > w) { p.x = w; p.vx = -Math.abs(p.vx) * 0.4; }
                        if (p.y < 0) { p.y = 0; p.vy = Math.abs(p.vy) * 0.4; }
                        else if (p.y > h) { p.y = h; p.vy = -Math.abs(p.vy) * 0.4; }

                        // --- COLLISIONE TAO ---
                        const tdx = p.x - cx;
                        const tdy = p.y - cy;
                        const tDistSq = tdx * tdx + tdy * tdy;
                        if (tDistSq < rSq) {
                            let tDist = Math.sqrt(tDistSq);
                            if (tDist < 0.1) tDist = 0.1;
                            const invDist = 1.0 / tDist;
                            const nx = tdx * invDist;
                            const ny = tdy * invDist;
                            const push = (r - tDist) * 0.3;
                            p.x += nx * push;
                            p.y += ny * push;
                            const dot = p.vx * nx + p.vy * ny;
                            if (dot < 0) {
                                p.vx -= 1.6 * dot * nx;
                                p.vy -= 1.6 * dot * ny;
                            }
                        }

                        p.life -= p.decay * df;

                        // --- COLORE ---
                        const alpha = Math.max(0, p.life);
                        let red, green, blue;

                        if (p.isFire) {
                            red = pc2r;
                            green = Math.min(1.0, pc2.g / 255 + p.life * 50 / 255);
                            blue = pc2b;
                        } else {
                            // speedSq diretto: evita Math.sqrt, visivamente equivalente con additive blending
                            const speedSq = p.vx * p.vx + p.vy * p.vy;
                            red = Math.min(1.0, pc1r + speedSq * 8 / 255);
                            green = Math.min(1.0, pc1g + speedSq * 4 / 255);
                            blue = pc1b;
                        }

                        // OPT 1: scrivi direttamente nel buffer interleaved
                        // Evita di scrivere su 3 array separati con 3 indici diversi
                        data[bi] = (p.x / w) * 2 - 1;          // NDC x
                        data[bi + 1] = -((p.y / h) * 2 - 1);       // NDC y (Y invertita)
                        data[bi + 2] = red;
                        data[bi + 3] = green;
                        data[bi + 4] = blue;
                        data[bi + 5] = alpha * 0.85;
                        data[bi + 6] = p.size;

                    } else {
                        // --- RESPAWN ---
                        this.respawn(p, cx, cy, r);

                        // Particella appena respawnata: invisibile finché non aggiornata
                        data[bi + 5] = 0; // alpha = 0
                    }
                }
            }

            render() {
                const gl = this.gl;
                const activeCount = Math.min(Config.particles, Config.maxParticles);
                const stride = this.STRIDE_BYTES; // 28 byte

                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                // OPT 1: un solo bindBuffer + bufferData invece di 3
                gl.bindBuffer(gl.ARRAY_BUFFER, this.bufInterleaved);

                // OPT 6: bufferData con srcOffset + length invece di subarray().
                // subarray() crea una TypedArray view temporanea ad ogni frame;
                // l'overload a 5 argomenti evita l'allocazione e copia solo i dati attivi.
                // OPT 2: STREAM_DRAW comunica al driver che il buffer viene riscritto
                // interamente ogni frame senza riuso — permette ottimizzazioni di allocazione.
                gl.bufferData(gl.ARRAY_BUFFER, this.dataInterleaved, gl.STREAM_DRAW,
                    0, activeCount * this.STRIDE);

                // OPT 4: usa location in cache invece di chiamare getAttribLocation
                const { pos, color, size } = this.loc;

                // OPT 1: tre vertexAttribPointer sullo stesso buffer con offset diversi
                gl.enableVertexAttribArray(pos);
                gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, stride, 0);  // offset 0: x,y

                gl.enableVertexAttribArray(color);
                gl.vertexAttribPointer(color, 4, gl.FLOAT, false, stride, 8);  // offset 8: r,g,b,a

                gl.enableVertexAttribArray(size);
                gl.vertexAttribPointer(size, 1, gl.FLOAT, false, stride, 24); // offset 24: size

                gl.drawArrays(gl.POINTS, 0, activeCount);
            }
        }

        // --- MAIN APP ---
        const overlay = new TaoOverlay('uiCanvas');
        const engine = new ParticleEngine('glCanvas');

        function resize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            overlay.resize(w, h);
            engine.resize(w, h);
        }

        window.addEventListener('resize', resize);

        // Rileva cambio DPR (spostamento su schermo con densità diversa)
        let dprMq = null;
        function watchDpr() {
            if (dprMq) dprMq.removeEventListener('change', onDprChange);
            const dpr = window.devicePixelRatio || 1;
            dprMq = window.matchMedia(`(resolution: ${dpr}dppx)`);
            dprMq.addEventListener('change', onDprChange);
        }
        function onDprChange() { resize(); watchDpr(); }
        watchDpr();
        resize();

        let lastTime = 0;
        function loop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            let dt = (timestamp - lastTime) / 1000;
            if (dt > 0.1) dt = 0.1;
            lastTime = timestamp;

            Config.rotation += Config.speed * Config.direction * dt;

            engine.updatePhysics(dt);
            engine.render();
            overlay.draw();

            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        // --- INTERFACCIA QML ---
        window.updateMouse = (x, y, inside) => {
            Mouse.x = x;
            Mouse.y = y;
            Mouse.inside = inside;
        };

        window.updateSettings = (s) => {
            if (!s) return;
            const data = (typeof s === 'object') ? s : {};

            if (data.particleCount !== undefined) Config.particles = Number(data.particleCount);
            if (data.rotationSpeed !== undefined) Config.speed = Number(data.rotationSpeed) * 0.06;
            if (data.clockwise !== undefined) Config.direction = data.clockwise ? 1 : -1;
            if (data.showClock !== undefined) Config.showClock = data.showClock;

            if (data.hourHandColor) Config.hourHandColor = toCssColor(data.hourHandColor);
            if (data.minuteHandColor) Config.minuteHandColor = toCssColor(data.minuteHandColor);
            if (data.secondHandColor) Config.secondHandColor = toCssColor(data.secondHandColor);

            if (data.glowColor1 !== undefined) {
                Config.glowColor1 = toCssColor(data.glowColor1);
                overlay.glowDirty = true;
            }
            if (data.glowSize1 !== undefined) {
                Config.glowSize1 = Number(data.glowSize1);
                overlay.glowDirty = true;
            }
            if (data.glowColor2 !== undefined) {
                Config.glowColor2 = toCssColor(data.glowColor2);
                overlay.glowDirty = true;
            }
            if (data.glowSize2 !== undefined) {
                Config.glowSize2 = Number(data.glowSize2);
                overlay.glowDirty = true;
            }

            // Parser RGB per le particelle (necessitano di componenti numeriche)
            const parseToRGB = (c) => {
                const css = toCssColor(c);
                const temp = document.createElement('canvas').getContext('2d');
                temp.fillStyle = 'black';
                temp.fillStyle = css;
                const computed = temp.fillStyle;
                if (computed.startsWith('rgba') || computed.startsWith('rgb')) {
                    const m = computed.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                    return m ? { r: +m[1], g: +m[2], b: +m[3] } : { r: 128, g: 128, b: 128 };
                }
                if (computed.startsWith('#')) {
                    return {
                        r: parseInt(computed.substr(1, 2), 16),
                        g: parseInt(computed.substr(3, 2), 16),
                        b: parseInt(computed.substr(5, 2), 16)
                    };
                }
                return { r: 128, g: 128, b: 128 };
            };

            if (data.particleColor1) Config.particleColor1 = parseToRGB(data.particleColor1);
            if (data.particleColor2) Config.particleColor2 = parseToRGB(data.particleColor2);

            if (data.particleSize !== undefined) Config.particleSize = Number(data.particleSize);
            if (data.particleSizeRandom !== undefined) Config.particleSizeRandom = Number(data.particleSizeRandom);
        };

        window.setParticleColors = (r1, g1, b1, r2, g2, b2) => {
            Config.particleColor1 = { r: r1, g: g1, b: b1 };
            Config.particleColor2 = { r: r2, g: g2, b: b2 };
        };
    </script>
</body>

</html>