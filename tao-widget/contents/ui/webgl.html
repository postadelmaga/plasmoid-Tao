<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: transparent;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #glCanvas {
            z-index: 1;
        }

        #uiCanvas {
            z-index: 2;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <canvas id="glCanvas"></canvas>
    <canvas id="uiCanvas"></canvas>

    <script>
        // --- CONFIGURAZIONE CENTRALE ---
        const Config = {
            particles: 80,
            speed: 0.005,
            direction: 1,   // 1 or -1
            showClock: false,
            lowCpu: false,
            rotation: 0,
            maxParticles: 3000,
            // Colori come nel C++ (particleColor1 = ciano, particleColor2 = fuoco)
            particleColor1: { r: 128, g: 204, b: 255 },   // pc1 – base (tipo normale)
            particleColor2: { r: 255, g: 100, b: 25 }    // pc2 – fuoco (1 su 7)
        };

        const Mouse = { x: -1000, y: -1000, inside: false };

        // --- SHADERS ---
        // Usa vertex color packed per replicare il comportamento C++ (colore varia con speed)
        const SHADERS = {
            vs: `
                attribute vec2 a_position;
                attribute vec4 a_color;
                attribute float a_size;
                varying vec4 v_color;

                void main() {
                    v_color = a_color;
                    gl_Position = vec4(a_position, 0.0, 1.0);
                    gl_PointSize = a_size;
                }
            `,
            fs: `
                precision mediump float;
                varying vec4 v_color;

                void main() {
                    float d = distance(gl_PointCoord, vec2(0.5));
                    if (d > 0.5) discard;
                    // Glow radiale esattamente come la glow texture del C++
                    float alpha = smoothstep(0.5, 0.0, d);
                    gl_FragColor = vec4(v_color.rgb, v_color.a * alpha);
                }
            `
        };

        // --- CLASSE: OVERLAY 2D (Tao e Orologio) ---
        class TaoOverlay {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext("2d");
                this.width = 0;
                this.height = 0;
            }

            resize(w, h) {
                this.width = this.canvas.width = w;
                this.height = this.canvas.height = h;
            }

            draw() {
                const ctx = this.ctx;
                const { width, height } = this;
                const r = Math.min(width, height) / 4.5;
                const cx = width / 2;
                const cy = height / 2;

                ctx.clearRect(0, 0, width, height);
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(Config.rotation);

                if (!Config.lowCpu) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = "rgba(100, 200, 255, 0.5)";
                }

                this.drawTaoBody(ctx, r);
                ctx.restore();

                if (Config.showClock) {
                    this.drawClock(ctx, cx, cy, r);
                }
            }

            drawTaoBody(ctx, r) {
                ctx.fillStyle = "#fff";
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = "#000";
                ctx.beginPath();
                ctx.arc(0, 0, r, -Math.PI / 2, Math.PI / 2);
                ctx.arc(0, r / 2, r / 2, Math.PI / 2, -Math.PI / 2, true);
                ctx.arc(0, -r / 2, r / 2, Math.PI / 2, -Math.PI / 2, false);
                ctx.fill();

                ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(0, -r / 2, r / 7, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(0, r / 2, r / 7, 0, Math.PI * 2); ctx.fill();
            }

            drawClock(ctx, cx, cy, r) {
                const now = new Date();
                const s = now.getSeconds() + now.getMilliseconds() / 1000;
                const m = now.getMinutes() + s / 60;
                const h = (now.getHours() % 12) + m / 60;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.lineCap = "round";

                const hand = (val, max, len, width, color) => {
                    const angle = (val / max) * Math.PI * 2 - Math.PI / 2;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = width;
                    ctx.beginPath(); ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
                    ctx.stroke();
                };

                hand(h, 12, r * 0.5, 5, "rgba(255,255,255,0.8)");
                hand(m, 60, r * 0.8, 3, "rgba(136,204,255,0.8)");
                hand(s, 60, r * 0.9, 1.5, "rgba(255,170,136,0.8)");

                ctx.restore();
            }
        }

        // --- CLASSE: MOTORE PARTICELLE (fisica identica al C++) ---
        class ParticleEngine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.gl = this.canvas.getContext("webgl", { alpha: true, antialias: true });

                this.count = Config.maxParticles;
                this.particles = [];
                this.width = 1;
                this.height = 1;

                // Typed arrays: posizione, colore (rgba float), size
                this.dataPos = new Float32Array(this.count * 2);
                this.dataColor = new Float32Array(this.count * 4);
                this.dataSize = new Float32Array(this.count);

                this.initGL();
                this.initParticles();
            }

            initGL() {
                const gl = this.gl;
                const createShader = (type, src) => {
                    const s = gl.createShader(type);
                    gl.shaderSource(s, src);
                    gl.compileShader(s);
                    return s;
                };

                const prog = gl.createProgram();
                gl.attachShader(prog, createShader(gl.VERTEX_SHADER, SHADERS.vs));
                gl.attachShader(prog, createShader(gl.FRAGMENT_SHADER, SHADERS.fs));
                gl.linkProgram(prog);
                gl.useProgram(prog);
                this.program = prog;

                this.bufPos = gl.createBuffer();
                this.bufColor = gl.createBuffer();
                this.bufSize = gl.createBuffer();

                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // additive come il C++
            }

            resize(w, h) {
                this.canvas.width = w;
                this.canvas.height = h;
                this.width = w;
                this.height = h;
                this.gl.viewport(0, 0, w, h);
            }

            initParticles() {
                for (let i = 0; i < this.count; i++) {
                    this.particles.push({
                        x: 0, y: 0, vx: 0, vy: 0,
                        life: 0,          // start dead → respawn subito
                        decay: 0.003 + Math.random() * 0.008,
                        // size in pixel come C++: 2..10
                        size: 2.0 + Math.random() * 8.0,
                        isFire: (i % 7 === 0)   // 1 su 7 è fuoco, come C++ (i % 7)
                    });
                }
            }

            // --- RESPAWN: identico al C++ ---
            respawn(p, cx, cy, r) {
                p.life = 1.0;

                const angle = Math.random() * Math.PI * 2;
                // dist = r * (0.5 + rnd * 2.0)  → da 0.5r a 2.5r dal centro
                const dist = r * (0.5 + Math.random() * 2.0);

                p.x = cx + Math.cos(angle) * dist;
                p.y = cy + Math.sin(angle) * dist;

                // Velocità iniziale come C++: ±0.3 px/frame (prima dello scaling df)
                p.vx = (Math.random() - 0.5) * 0.6;
                p.vy = (Math.random() - 0.5) * 0.6;

                // Se spawna dentro il Tao, spingila fuori (come il C++)
                const sdx = p.x - cx;
                const sdy = p.y - cy;
                if (sdx * sdx + sdy * sdy < r * r) {
                    p.x += sdx > 0 ? r : -r;
                }

                p.decay = 0.003 + Math.random() * 0.008;
                p.size = 2.0 + Math.random() * 8.0;
            }

            // --- FISICA: porta identicamente dal C++ ---
            updatePhysics(dt) {
                const df = dt * 60.0;   // delta factor (come C++)
                const activeCount = Math.min(Config.particles, Config.maxParticles);

                const w = this.width;
                const h = this.height;
                const cx = w * 0.5;
                const cy = h * 0.5;
                const r = Math.min(w, h) / 4.5;   // stesso calcolo C++
                const rSq = r * r;

                // Mouse in pixel (come C++, usa coordinate pixel dirette)
                const mx = Mouse.x;
                const my = Mouse.y;
                const isMouseValid = Mouse.inside && mx >= 0 && my >= 0 && mx <= w && my <= h;

                const pc1 = Config.particleColor1;
                const pc2 = Config.particleColor2;

                const friction = Math.pow(0.98, df);   // pre-calcolo come C++

                for (let i = 0; i < activeCount; i++) {
                    const p = this.particles[i];

                    if (p.life > 0.0) {

                        // --- MOUSE (identico C++) ---
                        const dx = mx - p.x;
                        const dy = my - p.y;

                        if (isMouseValid && Math.abs(dx) < 300 && Math.abs(dy) < 300) {
                            const distSq = dx * dx + dy * dy;
                            if (distSq < 90000.0) {
                                // Attrazione forte: f = 3.5 / (distSq + 100)
                                const f = 3.5 / (distSq + 100.0);
                                p.vx += dx * f * df;
                                p.vy += dy * f * df;
                            } else {
                                p.vx *= friction;
                                p.vy *= friction;
                            }
                        } else {
                            p.vx *= friction;
                            p.vy *= friction;
                        }

                        // --- MOVIMENTO ---
                        p.x += p.vx * df;
                        p.y += p.vy * df;

                        // --- BOUNDARY (rimbalzo con smorzamento 0.4) ---
                        if (p.x < 0) { p.x = 0; p.vx = Math.abs(p.vx) * 0.4; }
                        else if (p.x > w) { p.x = w; p.vx = -Math.abs(p.vx) * 0.4; }
                        if (p.y < 0) { p.y = 0; p.vy = Math.abs(p.vy) * 0.4; }
                        else if (p.y > h) { p.y = h; p.vy = -Math.abs(p.vy) * 0.4; }

                        // --- COLLISIONE TAO (identico C++) ---
                        const tdx = p.x - cx;
                        const tdy = p.y - cy;
                        const tDistSq = tdx * tdx + tdy * tdy;

                        if (tDistSq < rSq) {
                            let tDist = Math.sqrt(tDistSq);
                            if (tDist < 0.1) tDist = 0.1;
                            const invDist = 1.0 / tDist;
                            const nx = tdx * invDist;
                            const ny = tdy * invDist;

                            // Spinta graduale fuori (come C++: push = (r - tDist) * 0.3)
                            const push = (r - tDist) * 0.3;
                            p.x += nx * push;
                            p.y += ny * push;

                            // Rimbalzo con coefficiente 1.6 (come C++)
                            const dot = p.vx * nx + p.vy * ny;
                            if (dot < 0) {
                                p.vx -= 1.6 * dot * nx;
                                p.vy -= 1.6 * dot * ny;
                            }
                        }

                        p.life -= p.decay * df;

                        // --- COLORE (dinamico per speed, come C++) ---
                        const alpha = Math.max(0, p.life);
                        let red, green, blue;

                        if (p.isFire) {
                            // pc2 con verde modulato dalla vita
                            red = pc2.r / 255;
                            green = Math.min(1.0, pc2.g / 255 + p.life * 50 / 255);
                            blue = pc2.b / 255;
                        } else {
                            // pc1 con sovra-saturazione per velocità
                            const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                            red = Math.min(1.0, pc1.r / 255 + speed * 400 / 255);
                            green = Math.min(1.0, pc1.g / 255 + speed * 200 / 255);
                            blue = pc1.b / 255;
                        }

                        const ci = i * 4;
                        this.dataColor[ci] = red;
                        this.dataColor[ci + 1] = green;
                        this.dataColor[ci + 2] = blue;
                        this.dataColor[ci + 3] = alpha * 0.85; // leggermente trasparente

                    } else {
                        // --- RESPAWN ---
                        this.respawn(p, cx, cy, r);
                    }

                    // Converti pixel → NDC per il rendering WebGL
                    this.dataPos[i * 2] = (p.x / w) * 2 - 1;
                    this.dataPos[i * 2 + 1] = -((p.y / h) * 2 - 1); // Y invertita

                    // Size in pixel passata direttamente come gl_PointSize
                    this.dataSize[i] = p.size;
                }
            }

            render() {
                const gl = this.gl;
                const activeCount = Math.min(Config.particles, Config.maxParticles);

                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                const bindAttrib = (name, buffer, data, size) => {
                    const loc = gl.getAttribLocation(this.program, name);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(loc);
                    gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
                };

                bindAttrib("a_position", this.bufPos, this.dataPos.subarray(0, activeCount * 2), 2);
                bindAttrib("a_color", this.bufColor, this.dataColor.subarray(0, activeCount * 4), 4);
                bindAttrib("a_size", this.bufSize, this.dataSize.subarray(0, activeCount), 1);

                gl.drawArrays(gl.POINTS, 0, activeCount);
            }
        }

        // --- MAIN APP ---
        const overlay = new TaoOverlay("uiCanvas");
        const engine = new ParticleEngine("glCanvas");

        function resize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            overlay.resize(w, h);
            engine.resize(w, h);
        }
        window.addEventListener('resize', resize);
        resize();

        let lastTime = 0;
        function loop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            let dt = (timestamp - lastTime) / 1000;
            if (dt > 0.1) dt = 0.1;   // cap per lag spike (come C++)
            lastTime = timestamp;

            // speedFactor 0.06 come nel C++
            const df = dt * 60;
            Config.rotation += Config.speed * Config.direction * df * 0.06;

            if (!Config.lowCpu) {
                engine.updatePhysics(dt);
                engine.render();
            }
            overlay.draw();

            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        // --- INTERFACCIA QML ---
        window.updateMouse = (x, y, inside) => {
            Mouse.x = x;
            Mouse.y = y;
            Mouse.inside = inside;
        };

        window.updateSettings = (
            particleCount,
            rotationSpeed,
            clockwise,
            showClock,
            lowCpuMode,
            hourHandColor,
            minuteHandColor,
            secondHandColor,
            glowColor1,
            glowSize1,
            glowColor2,
            glowSize2,
            particleColor1,
            particleColor2
        ) => {
            Config.particles = particleCount;
            Config.speed = rotationSpeed;
            Config.direction = clockwise ? 1 : -1; // 1 or -1
            Config.showClock = showClock;
            Config.lowCpu = lowCpuMode;
            Config.hourHandColor = hourHandColor;
            Config.minuteHandColor = minuteHandColor;
            Config.secondHandColor = secondHandColor;
            Config.glowColor1 = glowColor1;
            Config.glowSize1 = glowSize1;
            Config.glowColor2 = glowColor2;
            Config.glowSize2 = glowSize2;
            Config.particleColor1 = particleColor1;
            Config.particleColor2 = particleColor2;
        };

        // Imposta colori particelle (equivalente setParticleColor1/2 del C++)
        window.setParticleColors = (r1, g1, b1, r2, g2, b2) => {
            Config.particleColor1 = { r: r1, g: g1, b: b1 };
            Config.particleColor2 = { r: r2, g: g2, b: b2 };
        };
    </script>
</body>

</html>